#[Name(test)]

#[Prototype]
fn Print(str : string)

type string
{
  head : char&
}

#[Prototype]
operator +(s : char&, offset : uint) -> char&

operator [](s : string, i : uint) -> char
{
  return s.head + i
}

/*
#[Prototype]
fn PrintBuffer(buffer : char&, length : uint)

fn PrintInt(n : uint, base : uint)
{
  buffer : char[16u]
  temp : uint = n
  i : int = 0

  do
  {
    temp = n % base
    buffer[i++] = (temp < 10u) ? ('0' + Cast<Char>(temp)) : ('a' + Cast<char>(temp - 10u));    
  } while ((n /= base) > 0u)

  buffer[i--] = '\0';

  for (j : uint in (0..i))
  {
    temp = buffer[j]
    buffer[j] = buffer[i]
    buffer[i] = temp
    i--
  }

  PrintBuffer(buffer, i)
}
*/

#[Entry]
fn Main() -> int
{
//  (10u > 5u ? Print("True!\n") : Print("False :(\n"))

  // NOTE(Isaac): we need to constant-fold these conditions, because x86 doesn't have an instruction to compare
  // two immediates
  i : uint = 2u
  if (i > 5u)
  {
    Print("Yaayyy\n")
  }
  else
  {
    Print("Nahhh :(\n")
  }

  return 0
}
